name: 🏥 Health Check

on:
  schedule:
    # Run health checks every 30 minutes
    - cron: '*/30 * * * *'
  workflow_dispatch:

env:
  STAGING_URL: 'https://staging.your-domain.com'
  PRODUCTION_URL: 'https://your-domain.com'

jobs:
  health-check:
    name: 🏥 Application Health Check
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: [staging, production]

    steps:
      - name: 📂 Checkout Code
        uses: actions/checkout@v4

      - name: 🔍 Check Application Health
        id: health-check
        run: |
          if [ "${{ matrix.environment }}" == "staging" ]; then
            URL="${{ env.STAGING_URL }}"
          else
            URL="${{ env.PRODUCTION_URL }}"
          fi
          
          echo "🔍 Checking health of ${{ matrix.environment }} environment at $URL"
          
          # Check if URL is reachable (replace with actual health check endpoint)
          if curl -f --max-time 30 --retry 3 "$URL/api/health" > /dev/null 2>&1; then
            echo "✅ ${{ matrix.environment }} is healthy"
            echo "status=healthy" >> $GITHUB_OUTPUT
          else
            echo "❌ ${{ matrix.environment }} is unhealthy"
            echo "status=unhealthy" >> $GITHUB_OUTPUT
          fi

      - name: 📊 Check Response Time
        if: steps.health-check.outputs.status == 'healthy'
        run: |
          if [ "${{ matrix.environment }}" == "staging" ]; then
            URL="${{ env.STAGING_URL }}"
          else
            URL="${{ env.PRODUCTION_URL }}"
          fi
          
          # Measure response time
          RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' "$URL/api/health")
          echo "⏱️ Response time for ${{ matrix.environment }}: ${RESPONSE_TIME}s"
          
          # Alert if response time is too high (> 5 seconds)
          if (( $(echo "$RESPONSE_TIME > 5.0" | bc -l) )); then
            echo "⚠️ High response time detected!"
          fi

      - name: 🔍 Check Database Connection
        if: steps.health-check.outputs.status == 'healthy'
        run: |
          if [ "${{ matrix.environment }}" == "staging" ]; then
            URL="${{ env.STAGING_URL }}"
          else
            URL="${{ env.PRODUCTION_URL }}"
          fi
          
          # Check database health endpoint
          if curl -f --max-time 10 "$URL/api/health/database" > /dev/null 2>&1; then
            echo "✅ Database connection healthy"
          else
            echo "❌ Database connection issues detected"
          fi

      - name: 📬 Send Alert on Failure
        if: steps.health-check.outputs.status == 'unhealthy'
        run: |
          echo "🚨 ALERT: ${{ matrix.environment }} environment is down!"
          echo "Timestamp: $(date)"
          echo "Environment: ${{ matrix.environment }}"
          
          # In a real scenario, you would send notifications to:
          # - Slack/Teams
          # - Email
          # - PagerDuty
          # - SMS
          
          # For now, we'll just create an issue
          echo "Creating GitHub issue for tracking..."

      - name: 📝 Create Issue on Failure
        if: steps.health-check.outputs.status == 'unhealthy'
        uses: actions/github-script@v7
        with:
          script: |
            const title = `🚨 Health Check Failed - ${{ matrix.environment }}`;
            const body = `
            ## 🚨 Health Check Alert
            
            **Environment:** ${{ matrix.environment }}
            **Status:** Unhealthy
            **Timestamp:** ${new Date().toISOString()}
            **Workflow:** [Health Check](${context.payload.repository.html_url}/actions/runs/${context.runId})
            
            ### 🔍 Details
            - Application health endpoint is not responding
            - This issue was automatically created by the health check workflow
            - Please investigate and resolve the issue
            
            ### 📋 Next Steps
            1. Check application logs
            2. Verify infrastructure status
            3. Check database connectivity
            4. Review recent deployments
            
            ---
            *This issue will be automatically closed when health checks pass*
            `;
            
            // Check if there's already an open issue for this environment
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'health-check,alert,${{ matrix.environment }}'
            });
            
            if (issues.data.length === 0) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['health-check', 'alert', '${{ matrix.environment }}', 'bug']
              });
            }

  close-resolved-issues:
    name: 🔄 Close Resolved Issues
    runs-on: ubuntu-latest
    needs: health-check
    if: always()

    steps:
      - name: 🔄 Close Health Check Issues
        uses: actions/github-script@v7
        with:
          script: |
            // Get all open health check issues
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'health-check,alert'
            });
            
            for (const issue of issues.data) {
              // Close issues for environments that are now healthy
              const closeComment = `
              ✅ **Health Check Resolved**
              
              This issue has been automatically resolved as the health checks are now passing.
              
              **Resolved at:** ${new Date().toISOString()}
              **Workflow:** [Health Check](${context.payload.repository.html_url}/actions/runs/${context.runId})
              `;
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: closeComment
              });
              
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                labels: [...issue.labels.map(l => l.name), 'resolved']
              });
            }
